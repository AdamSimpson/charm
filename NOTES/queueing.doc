To: ppl@cs.uiuc.edu
Subject: New queueing system
--text follows this line--


Instead of CqsEnqueue, you call any one of these functions to enqueue
your messages:

	CqsEnqueueGeneral(queue, message, strategy, numpriobits, prioptr)
	CqsEnqueueFifo(queue, message)
	CqsEnqueueLifo(queue, message)
	CqsEnqueue(queue, message)

	Queue *queue;
	void *message;
        int strategy;
	unsigned int numpriobits;
	unsigned int *prioptr;

queue is a queue, which must have been returned by CqsCreate().

message is the message.  The queueing system does not examine this
pointer at all, so it could in fact be a pointer to anything, or
even an int coerced to a pointer.

strategy is one of the following integer constants:

    CQS_QUEUEING_FIFO
    CQS_QUEUEING_LIFO
    CQS_QUEUEING_IFIFO
    CQS_QUEUEING_ILIFO
    CQS_QUEUEING_BFIFO
    CQS_QUEUEING_BLIFO

if you are using one of the strategies IFIFO or ILIFO, then prioptr is
a pointer to a SIGNED integer priority, and numpriobits is ignored.

If you are using one of the strategies BFIFO or BLIFO, then Prioptr is
a pointer to a bitvector, and numpriobits is the length of the
bitvector measured in bits.  The bitvector DOESN'T use the same format
as the old bitvector priorities in charm.  Instead, it works like
this: the bitvector is an array of ints.  The first bit of the
bitvector is stored in the most-significant bit of the first integer.
The next 31 bits of the bitvector are in the less significant bits of
the first integer, in order.  The 32nd bit of the bitvector is in the
most-significant bit of the second integer, and so on.

To dequeue a message, call CqsDequeue.  The order in which messages are
dequeued is as follows:

	1. Among messages enqueued with bitvector priorities, the
	   messages are dequeued according to their priority.  The
	   priority "0000..." is dequeued first, and "1111..." is
	   dequeued last.  All bits beyond numpriobits are assumed to
	   be zero.

	2. Unprioritized messages are treated as if they had the
	   priority "1000..." (which is the "middle" priority, it
	   lies exactly halfway between "0000..." and "1111...")

	3. Integer priorities are converted to bitvector priorities.
	   They are normalized so that the integer priority of zero
	   is converted to "1000..." (the "middle" priority).
	   To be more specific, the conversion is performed by
	   coercing the integer to an unsigned integer, adding
	   0x80000000, and treating the resulting 32-bit number
	   as a 32-bit bitvector priority.

	4. Among messages with the same priority, messages are
	   dequeued in FIFO order or LIFO order, depending upon which
	   queuing function was used.

Note: for each CqsEnqueueXXX, there is a matching CsdEnqueueXXX.

Here is a temporary "fix" which enables us to use this system from inside
charm:

	1. Any message allocated with CkAllocMsg is enqueued using
	   CqsEnqueueFifo, by default.

	2. Any message allocated with CkAllocPrioMsg is enqueued using
	   CqsEnqueueBFifo, by default.

	3. CkAllocPrioMsg's third argument is now the number of BITS, not
	   words, needed to store the priority.  If you want to store an
	   integer priority, you have to use

		CkAllocPrioMsg(type, sizes, sizeof(int)*8)

	   And if you want to store a bitvector priority, you have to use
	   
		CkAllocPrioMsg(type, sizes, BITS);

	4. The queueing strategy of a message can be changed with the
	   following calls:

	   CkSetQueueing(msg, CK_QUEUEING_FIFO);
	   CkSetQueueing(msg, CK_QUEUEING_LIFO);
	   CkSetQueueing(msg, CK_QUEUEING_IFIFO);
	   CkSetQueueing(msg, CK_QUEUEING_ILIFO);
	   CkSetQueueing(msg, CK_QUEUEING_BFIFO);
	   CkSetQueueing(msg, CK_QUEUEING_BLIFO);

Note that this system is backward compatible with programs that used fifo
queueing, but it requires at least a little modification to programs
that used anything else.  Of course, we really need to redo the
charm interface, but that will require translator modification, so
I left it for later.

- Josh
