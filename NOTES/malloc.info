To: ppl@cs.uiuc.edu
Subject: Recent changes.
 
At Sanjay's request, I just made the changes necessary to reenable interrupts
on the network version.  The big impediment is that the interrupt handler
needed to be able to call "malloc", but malloc isn't normally reentrant.
Here's what I did to solve the problem:

 
I created these macros:
 
  CmiInterruptBlock()   - blocks all interrupts.
  CmiInterruptRelease() - unblocks all interrupts.
  CmiInterruptHeader(funcname) - put this at the top of an interrupt
  handler to make it respect CmiInterruptBlock and CmiInterruptRelease.
  without this header, the block and release get ignored.

Next, I added a file "memory.c" to the common converse code.  This
file defines malloc, free, calloc, etc.  It has options to define them
in one of several ways.  One, it can use the code for GNU malloc.
Two, it can use the code for GNU malloc with wrappers that block
interrupts.  Three, it can use the OS's built-in malloc.

Finally, I put a flag into conv-mach.h that controls which
implementation of malloc to use.  In the network version, I used the
gnu malloc with interrupt-blocking.  In all other versions, I used the
OS malloc.

Finally, I reenabled interrupts, which work okay because of these
interrupt-blocking.

- Josh


