Here is the initial definition for the branch-office chare syntax,
along with intended implementation, and what the translator is 
expected to do for them.

branch-office-chare C {

manager { /* this runs on the "host" */
 Local variables (data area )
   
 MgrInit: (? no message )
   
 MgrEp1: (message ..)
   code
 MgrEp2: (message ..)
   code
 ..
 access functions
 }

branch { /* executes on node */
  Local variables (data area )

  BranchInit: (message ..)
  /* message contains identical vector for all branches */
 
  [ BranchSpecificInit: (message ..)
    /* message contains node-specific vector for all branches */
    /* This entry-point is optional. Almost no boc would need it */
   ]

  BranchEP1: (message ..)
   code;
  BranchEP2: (message ..)
   code;
  ...

 access functions
 }



--------------------------------------------------------------------------
The above should translate to definitions of two "objects"
one destined for the host, and the other for the node.

I.e.

All the node entry-points for all boc's are defined as a function,
with a unique serial number associated with each.
A jump table indexed by these numbers, and containing pointers
to the apt function is to be created in NodeInit.
(So, NodeInit will call a function for generating this table.
This function, called GenerateBocEPTbl(N), is to be generated by the 
translator. N is the number of system generated boc's.
The function should return a pointer to the table (which it allocates and 
fills). The system can fill in the eps for the system BOCs at this point
The access functions get transformed to accept a pointer to the data-area
as a parameter, and chnage all the refs to it accordingly.

All the host eps for bocs are similarly organized.

The host, at the beginning of the computation, sets up the activating initial 
messages for each BOC, in accordance with the host init ep.
The host Init EP must (a ) set up the "universal" initial message for all its 
branches. (b) send individualized messages for specific nodes, if needed.

The translator must create a BOCinit function, which calls all the host init
eps for each declared boc.
Notice that it is this mechanism that actually creates a BOC.
(and so allows for multiple BOCs with the same definition).
This function must also assign a serial number to each instancce of the boc.
Note that this is a different serial number than that associated with each
entry-point. This is dynamic (one for each INSTANCE).
This

[The messages will actually be collected and sent together. But neither the 
translator nor the user program be aware of this. They just use
BroadcastToBranches(MyBOCnum, EP = BranchInit,  Msg), and
SendToBOC(MyBocnum, EP [= BranchSpecificInit] Msg).]

On each node, the nodeInit will, when it receives the initial (broadcast)
message for each BOC, allocate the data-area for it,
make an entry in its BOCtbl for its serial number pointing to this data-area
and call the BranchInit EP for this chare.
Later on, when a mesage for boc numbered N, and directed at EP, arrives,
the node simply calls the function BocEPTbl[EP], with the data-area
argument set to BOCtbl[N].

(Incidentally, the names "BranchInit" "BranchSpecificInit" are used
for illustration here. The user may use any names they wish.
They are mentioned in the initial messages, which is sufficient.)

The system defined BOCs will also be similarly initialized.
The translator does not need to know about them except their count
(so it can assign the serial numbers to instances after this).
and their total number of EPs (again so it can assign serial no.s
to BOC EPs beyond this).
