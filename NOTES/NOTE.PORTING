-------------------------------------------------------------------------------
How to convert an old version of converse into a new version of converse:

   1. Convert machine.mk into conv-mach.mk.
   2. Create a conv-mach.h for the version.
   3. Reduce the machine layer to machine.c, spantree.c, and the header-files.
   4. Deal with the contents of machine.h
   5. Edit machine.c to fix the identifier names (change Mc to Cmi, etc).
   6. Change CmiInit --> CmiInitMc in the machine layer.
   7. Change CmiGetMsg --> CmiGetNonLocal in the machine layer.
   8. Add CmiLocalQueue to the machine layer.
   9. Add CmiAlloc, CmiSize, CmiFree to machine layer.
  10. Make sure machine.c only exports functions that start with "Cmi".

Details on this process described below.
-------------------------------------------------------------------------------
1. Converting machine.mk into conv-mach.mk.  This is easy.  Basically, I
just changed the names of the variables so that they all start with CMK_.
See the net-linux version for an example.
-------------------------------------------------------------------------------
2. Converting an old machine.h to a new conv-mach.h.  Copy the conv-mach.h
from the net-linux version, then change the flag-settings.  Each conv-mach.h
is basically a long list of flags.  For example, the net-linux version
contains this snippet:

        /* #define CMK_CMIMYPE_IS_A_BUILTIN */
           #define CMK_CMIMYPE_IS_A_VARIABLE
        
           #define CMK_CMIPRINTF_IS_A_BUILTIN
        /* #define CMK_CMIPRINTF_IS_JUST_PRINTF */

Indicating that in the net-linux version, CmiMyPe was implementeda as
a variable (Cmi_mype), and that CmiPrintf was implemented as a
function.  These flags enable converse.h to produce the correct macro
definitions and prototypes for CmiMyPe and CmiPrintf.  You must create
a similar flags-list for your machine version.  The easiest way to do
this is to edit the net-linux version.
-------------------------------------------------------------------------------
3. Reduce the machine layer to machine.c, spantree.c, and the
header-files.  Just do this by concatenating all the C files into
machine.c.  This simplifies the makefiles dramatically.
-------------------------------------------------------------------------------
4. Deal with the old machine.h.  My first observation is this: the
vast majority of the stuff in machine.h is not used at all, anywhere.
If it's not used, just ignore it.  The second observation is that the
majority of the rest of it is only used inside the machine layer
itself.  Such code can be cut an pasted into the machine layer
(machine.c, or a header file of your own invention included by
machine.c).  There is one other kind of thing in machine.h, namely,
Definitions of exported Cmi functions like "#define CmiMyPe() _MC_mypenum".
Usually, these are already accounted for in converse.h.  For example,
converse.h already contains:

             #ifdef CMK_CMIMYPE_IS_A_VARIABLE
                extern int Cmi_mype;
                extern int Cmi_numpe;
                #define CmiMyPe() Cmi_mype
                #define CmiNumPe() Cmi_numpe
             #endif

Therefore, the easiest way to handle the macro definition
"#define CmiMyPe() _MC_mypenum" is to convert _MC_mypenum to
Cmi_mype throughout the machine layer, and to set the flag
CMK_CMIMYPE_IS_A_VARIABLE.

Eventually, you may run into a macro which is not easily made to
conform to the possibilities laid out by the flags-list.  In this
case, you must add a new flag to the flags-list, and add a section
to converse.h.
-------------------------------------------------------------------------------
5. Edit machine.c to fix the identifier names (change Mc to Cmi, etc).
This is straightforward.
-------------------------------------------------------------------------------
6. Change CmiInit --> CmiInitMc in the machine layer.  machine.c no
longer contains CmiInit, instead, it contains CmiInitMc.  The prototype
for CmiInitMc is "void CmiInitMc(void **argv)".  It should initialize the
machine-specific part of the Cmi layer.  If it uses any arguments from
argv, it should remove them from argv.
-------------------------------------------------------------------------------
7. Change CmiGetMsg --> CmiGetNonLocal in the machine layer.  machine.c
no longer contains CmiGetMsg.  Instead, it contains CmiGetNonLocal, which
retrieves a message from the network.  (NOT from the CMI fifo queue).
Most machine layers already worked this way anyway, so it's just a question
of changing the function name.
-------------------------------------------------------------------------------
8. Add CmiLocalQueue to the machine layer.  This is the machine layer's
FIFO queue.  This must be declared as void* CmiLocalQueue, and must
be created inside CmiInitMc using CmiLocalQueue=FIFO_Create().  It can
then be used by machine-functions to enqueue messages-to-self.  In fact,
look for places in the machine layer where messages-to-self get enqueued
on the scheduler queue, and make sure they get enqueued on the CmiLocalQueue
instead.
-------------------------------------------------------------------------------
9. Add CmiAlloc, CmiSize, CmiFree to machine layer.  This is a bit hazy
in my mind.  Basically, CmiAlloc allocates memory, CmiSize returns the
size of a block you previously allocated, and CmiFree frees a block you
allocated with CmiAlloc.  It should work to cut the definitions
from the Common.net source code.  However, we need to think about how
to do this for real.
-------------------------------------------------------------------------------
10. Make sure machine.c only exports functions that start with "Cmi".
Take your "static" in hand, and distribute liberally.  In places where
you can't add a "static", change the function name to CmiSomething.
-------------------------------------------------------------------------------
