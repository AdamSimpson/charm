\chapter{Converse Parameter Marshalling}

The Converse Parameter Marshalling module's provides a concise means
of invoking functions on remote processors.  The CPM module handles
all the details of packing, transmitting, translating, and
unpacking the arguments.  It also takes care of converting function
pointers into function handles.  With all these details out of the
way, it is possible to perform remote function invocation in a single
line of code.

\section{CPM Basics}

The heart of the CPM module is the CPM scanner.  The scanner reads a C
source file.  When it sees the keyword {\tt CpmInvokable} in front of
one of the user's function declarations, it generates a {\it launcher}
for that particular function.  The {\it launcher} is a function whose
name is {\tt Cpm\_} concatenated to the name of the user's function.
The launcher accepts the same arguments as the user's function, plus a
{\it destination} argument.  Calling the {\it launcher} transmits a
message to another processor determined by the {\it destination}
argument.  When the message arrives and is handled, the user's
function is called.

For example, if the CPM scanner sees the following function
declaration

\begin{verbatim}
    CpmInvokable myfunc(int x, int y) { ... }
\end{verbatim}

The scanner will generate a launcher named {\tt Cpm\_myfunc}.
The launcher has this prototype:

\begin{verbatim}
    void Cpm_myfunc(CpmDestination destination, int x, int y);
\end{verbatim}

If I were to call {\tt Cpm\_myfunc} as follows:

\begin{verbatim}
    Cpm_myfunc(CpmSend(3), 8, 9);
\end{verbatim}

A message would be sent to processor 3 ordering it to call {\tt
myfunc(8,9)}.  Notice that the {\it destination} argument isn't just an
integer processor number.  The possible destinations for a message are
described later.

When the CPM scanner is applied to a C source file with a particular
name, it generates all its code in an include file with a similar
name: the {\tt .c} is replaced with {\tt .cpm.h}.  The include file
must be included in the original {\tt .c} file, near the top of the
file.  In addition, the code in the header file must be initialized by
calling {\tt CpmInitializeThisModule()} in the module that includes
the header file.

We demonstrate the use of the CPM mechanisms using the following
short program {\tt myprog.c}:

\begin{verbatim}
 1:    #include "myprog.cpm.h"
 2:   
 3:    CpmInvokable print_integer(int n)
 4:    {
 5:      CmiPrintf("%d\n", n);
 6:    }
 7:    
 8:    user_main(int argc, char **argv)
 9:    {
10:      int i;
11:      ConverseInit(argv);
12:      CpmModuleInit();
13:      CpmInitializeThisModule();
14:      if (CmiMyPe()==0)
15:        for (i=1; i<CmiNumPes(); i++)
16:          Cpm_print_integer(CpmSend(i), rand());
17:      CsdScheduler(-1);
18:      ConverseExit(0);
19:    }
\end{verbatim}

Lines 3-6 of this program contain a simple C function that prints an
integer.  The function is marked with the word {\tt CpmInvokable}.
When the CPM scanner sees this word, it adds the function {\tt
Cpm\_print\_integer} to the file {\tt myprog.cpm.h}.  The program
includes {\tt myprog.cpm.h} on line 1, and initializes the code in
there on line 13.  Each call to {\tt Cpm\_print\_integer} on line 16
builds a message that invokes {\tt print\_integer}.  The
destination-argument {\tt CpmSend(i)} causes the message to be sent to
the {\it i}'th processor.  Note the presence of {\tt CsdScheduler} on
line 17: messages that are sent by the CPM mechanism are received and
handled by the scheduler, like any other Converse message.

The effect of this program is that the first processor orders each of
the other processors to print a random number.
\pagebreak
All launchers accept a {\it CpmDestination} as their first argument.  A
{\it CpmDestination} is actually a pointer to a small C structure
containing routing and handling information.  The CPM module has many
built-in functions that return {\it CpmDestination}s.  Therefore, any
of these can be used as the first argument to a launcher:

\begin{itemize}

\item[]{{\bf CpmSend({\it pe})} - the message is transmitted to
processor {\it pe} with maximum priority}.

\item[]{{\bf CpmEnqueue({\it pe, queueing, priobits, prioptr})}
- The message is transmitted to processor {\it pe}, where it is
enqueued with the specified queueing strategy and priority.  The {\it
queueing}, {\it priobits}, and {\it prioptr} arguments are the same as
for {\bf CqsEnqueueGeneral}.}

\item[]{{\bf CpmEnqueueFIFO({\it pe})} - the message is transmitted to
processor {\it pe} and enqueued with the middle priority (zero), and
FIFO relative to messages with the same priority.}

\item[]{{\bf CpmEnqueueLIFO({\it pe})} - the message is transmitted to
processor {\it pe} and enqueued with the middle priority (zero), and
LIFO relative to messages with the same priority.}

\item[]{{\bf CpmEnqueueIFIFO({\it pe, prio})} - the message is
transmitted to processor {\it pe} and enqueued with the specified
integer-priority {\it prio}, and FIFO relative to messages with the
same priority.}

\item[]{{\bf CpmEnqueueILIFO({\it pe, prio})} - the message is
transmitted to processor {\it pe} and enqueued with the specified
integer-priority {\it prio}, and LIFO relative to messages with the
same priority.}

\item[]{{\bf CpmEnqueueBFIFO({\it pe, priobits, prioptr})} - the
message is transmitted to processor {\it pe} and enqueued with the
specified bitvector-priority, and FIFO relative to messages
with the same priority.}

\item[]{{\bf CpmEnqueueBLIFO({\it pe, priobits, prioptr})} - the
message is transmitted to processor {\it pe} and enqueued with the
specified bitvector-priority, and LIFO relative to messages with the
same priority.}

\item[]{{\bf CpmMakeThread({\it pe})} - The message is transmitted to
processor {\it pe} where a CthThread is created, and the thread
invokes the specified function.}

\end{itemize}

All the functions shown above accept processor numbers as arguments.
Instead of supplying a processor number, one can also supply the
special symbols CPM\_ALL or CPM\_OTHERS, causing a broadcast.  For
example,

\begin{verbatim}
Cpm_print_integer(CpmMakeThread(CPM_ALL), 5);
\end{verbatim}

Would broadcast a message to all the processors causing each processor
to create a thread, which would in turn invoke {\tt print\_integer}
with the argument 5.

\section{CPM Packing and Unpacking}

Functions preceeded by the word {\bf CpmInvokable} must have simple
argument lists.  In particular, the argument list of a CpmInvokable
function can only contain cpm-simple-arguments and cpm-array-arguments,
as defined by this grammar:

\begin{verbatim}
    cpm-single-argument :== typeword varname
    cpm-array-argument  :== typeword '*' varname
\end{verbatim}

When CPM sees the cpm-array-argument notation, CPM interprets it as
being a pointer to an array.  In this case, CPM attempts to pack an
entire array into the message, whereas it only attempts to pack a
single element in the case of the cpm-single-argument notation.

Each cpm-array-argument must be preceeded by a cpm-simple-argument of
type {\tt CpmDim}.  {\tt CpmDim} is simply an alias for {\tt int}, but
when CPM sees an argument declared {\tt CpmDim}, it knows that the
next argument will be a cpm-array-argument, and it interprets the {\tt
CpmDim} argument to be the size of the array.  Given a pointer to the
array, its size, and its element-type, CPM handles the packing of
array values as automatically as it handles single values.

For each type the user wishes to pack, the user must supply some pack
and unpack routines.  The subroutines needed depend upon whether the
type is a pointer or a simple type.  Simple types are defined to be
those that contain no pointers at all.  Note that some types fall
into neither category, CPM cannot currently handle such types.

CPM knows which type is which only through the following declarations:

\begin{verbatim}
    CpmDeclareSimple(typeword);
    CpmDeclarePointer(typeword);
\end{verbatim}

The user must supply such declarations for each type that must be sent
via CPM.

When packing a value {\tt v} which is a simple type, CPM uses the
following strategy.  The generated code first converts {\tt v} to
network interchange format by calling {\tt CpmPack\_typename(\&v)},
which must perform the conversion in-place.  It then copies {\tt v}
byte-for-byte into the message and sends it.  When the data arrives,
it is extracted from the message and converted back using {\tt
CpmUnpack\_typename(\&v)}, again in-place.  The user must supply the
pack and unpack routines.

When packing a value {\tt v} which is a pointer, the generated code
determines how much space is needed in the message buffer by calling
{\tt CpmPtrSize\_typename(v)}.  It then transfers the data pointed to
by {\tt v} into the message using {\tt CpmPtrPack\_typename(p, v) },
where {\tt p} is a pointer to the allocated space in the message
buffer.  When the message arrives, the generated code extracts the
packed data from the message by calling {\tt
CpmPtrUnpack\_typename(p)}.  The unpack function must return a pointer
to the unpacked data, which is allowed to still contain pointers to
the message buffer (or simply be a pointer to the message buffer).
When the invocation is done, the function {\tt
CpmPtrFree\_typename(v)} is called to free any memory allocated by the
unpack routine. The user must supply the size, pack, unpack, and free
routines.

CPM provides built-in pack routines for the following types: char,
short, int, long, float, double, and CpmStr (pointer to a
null-terminated string).  When using these types, no CpmDeclareSimple,
CpmDeclarePointer, or pack/unpack declarations are needed.

\section{Inventing new kinds of CpmDestinations}

It is possible for the user to invent new kinds of CpmDestinations,
and to write functions that return these new destinations.  In order
to do this, one must have a mental model of the steps performed when a
Cpm message is sent.  This knowledge is only necessary to those
wishing to invent new kinds of destinations.  Others can skip this
section.

\pagebreak
The basic steps taken when sending a CPM message are:

\begin{itemize}

\item[]{{\bf 1. The destination-structure is created.}  The first
argument to the launcher is a CpmDestination.  Therefore, before the
launcher is invoked, one typically calls a function (like CpmSend)
to build the destination-structure.}

\item[]{{\bf 2. The launcher allocates a message-buffer}.  The buffer
contains space to hold a function-pointer and the function's arguments.
It also contains space for an ``envelope'', the size of which is
determined by a field in the destination-structure.}

\item[]{{\bf 3. The launcher stores the function-arguments in the message
buffer}.  In doing so, the launcher converts the arguments to a
contiguous sequence of bytes.}

\item[]{{\bf 4. The launcher sets the message's handler}.  For every
launcher, there is a matching function called an {\it invoker}.  The
launcher's job is to put the argument data in the message and send the
message.  The {\it invoker}'s job is to extract the argument data from
the message and call the user's function.  The launcher uses {\tt
CmiSetHandler} to tell Converse to handle the message by calling the
appropriate {\it invoker}.}

\item[]{{\bf 5. The message is sent, received, and handled}. 
The destination-structure contains a pointer to a {\it send-function}.
The {\it send-function} is responsible for choosing the message's
destination and making sure that it gets there and gets handled.  The
{\it send-function} has complete freedom to implement this in any
manner it wishes.  Eventually, though, the message should arrive at a
destination and its handler should be called.}

\item[]{{\bf 6. The user's function is invoked}.  The invoker
extracts the function arguments from the message buffer and calls
the user's function.}

\end{itemize}

The {\it send-function} varies because messages take different
routes to get to their final destinations.  Compare, for example,
CpmSend to CpmEnqueueFIFO.  When CpmSend is used, the message goes
straight to the target processor and gets handled.  When
CpmEnqueueFIFO is used, the message goes to the target processor, goes
into the queue, comes out of the queue, and {\it then} gets handled.
The {\it send-function} must implement not only the transmission of
the message, but also the possible ``detouring'' of the message
through queues or into threads.

We now show an example CPM command, and describe the steps that are
taken when the command is executed.  The command we will consider is
this one:

\begin{verbatim}
Cpm_print_integer(CpmEnqueueFIFO(3), 12);
\end{verbatim}

Which sends a message to processor 3, ordering it to call {\tt
print\_integer(12)}.

The first step is taken by CpmEnqueueFIFO, which builds the
CpmDestination.  The following is the code for CpmEnqueueFIFO:

\pagebreak

\begin{verbatim}
typedef struct CpmDestinationSend
{
  void *(*sendfn)();
  int envsize;
  int pe;
}
*CpmDestinationSend;

CpmDestination CpmEnqueueFIFO(int pe)
{
  static struct CpmDestinationSend ctrl;
  ctrl.envsize = sizeof(int);
  ctrl.sendfn  = CpmEnqueueFIFO1;
  ctrl.pe = pe;
  return (CpmDestination)&ctrl;
}
\end{verbatim}

Notice that the CpmDestination structure varies, depending upon which
kind of destination is being used.  In this case, the destination
structure contains a pointer to the send-function {\tt
CpmEnqueueFIFO1}, a field that controls the size of the envelope, and
the destination-processor.  In a CpmDestination, the {\tt sendfn} and
{\tt envsize} fields are required, additional fields are optional.

After CpmEnqueueFIFO builds the destination-structure, the launcher
Cpm\_print\_integer is invoked.  Cpm\_print\_integer performs all the
steps normally taken by a launcher:

\begin{itemize}

\item[]{{\bf 1. It allocates the message buffer.}  In this case, it sets aside
just enough room for one {\it int} as an envelope, as dictated by the
destination-structure's {\it envsize} field.}

\item[]{{\bf 2. It stores the function-arguments in the message-buffer.}  In
this case, the function-arguments are just the integer 12.}

\item[]{{\bf 3. It sets the message's handler.}  In this case, the message's
handler is set to a function that will extract the arguments and call
print\_integer.}

\item[]{{\bf 4. It calls the send-function to send the message.}}
\end{itemize}

The code for the send-function is here:

\begin{verbatim}
void *CpmEnqueueFIFO1(CpmDestinationSend dest, int len, void *msg)
{
  int *env = (int *)CpmEnv(msg);
  env[0] = CmiGetHandler(msg);
  CmiSetHandler(msg, CpvAccess(CpmEnqueueFIFO2_Index));
  CmiSyncSendAndFree(dest->pe,len,msg);
}
\end{verbatim}

The send-function CpmEnqueueFIFO1 starts by switching the handler.
The original handler is removed using using {\tt CmiGetHandler}.  It
is set aside in the message buffer in the ``envelope'' space described
earlier --- notice the use of {\tt CpmEnv} to obtain the envelope.
This is the purpose of the envelope in the message --- it is a place
where the send-function can store information.  The
destination-function must anticipate how much space the send-function
will need, and it must specify that amount of space in the
destination-structure field {\it envsize}.  In this case, the envelope
is used to store the original handler, and the message's handler is
set to an internal function called {\tt CpmEnqueueFIFO2}.

After switching the handler, {\tt CpmEnqueueFIFO1} sends the message.
Eventually, the message will be received by {\tt CsdScheduler}, and
its handler will be called.  The result will be that {\tt
CpmEnqueueFIFO2} will be called on the destination processor.  Here is
the code for {\tt CpmEnqueueFIFO2}:

\begin{verbatim}
void CpmEnqueueFIFO2(void *msg)
{
  int *env;
  CmiGrabBuffer(&msg);
  env = (int *)CpmEnv(msg);
  CmiSetHandler(msg, env[0]);
  CsdEnqueueFIFO(msg);
}
\end{verbatim}

This function takes ownership of the message-buffer from Converse
using {\tt CmiGrabBuffer}.  It extracts the original handler from the
envelope (the handler that calls {\tt print\_integer}), and restores it
using {\tt CmiSetHandler}.  Having done so, it enqueues the message
with the FIFO queueing policy.  Eventually, the scheduler picks the
message from the queue, and {\tt print\_integer} is invoked.

In summary, the procedure for implementing new kinds of destinations
is to write one send-function, one function returning a CpmDestination
(which contains a reference to the send-function), and one or more
Converse handlers to manipulate the message.

The destination-function must return a pointer to a
``destination-structure'', which can in fact be any structure matching
the following specifications:

\begin{itemize}
\item{The first field must be a pointer to a send-function,}
\item{The second field must the an integer, the envelope-size.}
\end{itemize}

This pointer must be coerced to type CpmDestination.

The send-function must have the following prototype:

\begin{verbatim}
    void sendfunction(CpmDestination dest, int msglen, void *msgptr)
\end{verbatim}

It can access the envelope of the message using CpmEnv:

\begin{verbatim}
    int *CpmEnv(void *msg);
\end{verbatim}

And it can also access the data stored in the destination-structure
by the destination-function.

