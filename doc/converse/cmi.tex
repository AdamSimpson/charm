\chapter{Converse Machine Interface}

\internal{
\section{Initialization and Wrap-Up}

\function{void ConverseInit(char *argv[])}
\index{ConverseInit}
\desc{This function initializes the machine interface. It should be
called prior to any other Converse functions. 
Multiple calls to this function in a process should
be avoided. \param{argv} is in similar format as passed to
\param{main(argc, argv)}. 
They would be utilized by \param{ConverseInit()} to initialize
machine specific parameters such as number of processors.}

\function{void ConverseExit(void)}
\index{ConverseExit}
\desc{This function frees the resources acquired by Converse and wraps up. 
Any other Converse function should not be called after a call to this function.
\note{It does not terminate the calling
process. A separate call to \param{exit()} is needed after 
\param{ConverseExit()} to achieve this.}}
}


\section{Converse Handlers and Handler Numbers}

Prior to sending a message, the Converse user writes a {\em handler}
function that should be called by the receiving processor.  The
Converse user puts a reference to the {\em handler} function in the
message, and sends it to the destination processor.  The destination
processor automatically calls the user's {\em handler} function,
passing it the contents of the message.

Ideally, this would be achieved by putting a pointer to the
handler-function in the message.  However, in parallel programs
running on heterogeneous machines, sending a function pointer in a
message doesn't work.  As a substitute, we use {\em handler numbers}.
To this end, Converse maintains a table mapping handler numbers to
function pointers.  Each processor has its own copy of the mapping.
There is a caution associated with this approach: it is the user's
responsibility to ensure that all processors have identical mappings.
This is easy to do, nonetheless, the user must be aware that this is
(usually) required.

Note that while they may be called {\em handler numbers}, they are
essentially function numbers, and can be used as a general substitute
for function pointers regardless of whether those functions are handler
functions.

\function{typedef void (*CmiHandler)(void *)}
\index{CmiHandler}
\desc{Functions that handle Converse messages must be of this type.}

\function {int CmiRegisterHandler(CmiHandler h)}
\index{CmiRegisterHandler}
\desc{This represents the standard technique for associating numbers
with functions.  To use this technique, the Converse user registers
each of his functions, one by one, using CmiRegisterHandler.  One must
register exactly the same functions in exactly the same order on all
processors.  The system assigns monotonically increasing numbers to
the functions, the same numbers on all processors.  This insures
global consistency.  CmiRegisterHandler returns the number which was
chosen for the function being registered.}

\function {void CmiRegisterHandlerGlobal(int n, CmiHandler h)}
\index{CmiRegisterHandlerLocal}
\desc{This represents a second registration technique.   The Converse
user registers his functions on processor zero, using
CmiRegisterHandlerGlobal.  The Converse user is then responsible for
broadcasting those handler numbers to other processors, and installing
them using CmiNumberHandler below.  The user should take care not to
invoke those handlers until they are fully installed.}

\function {void CmiRegisterHandlerLocal(int n, CmiHandler h)}
\index{CmiRegisterHandlerLocal}
\desc{This function is used when one wishes to register functions
in a manner that is not consistent across processors.  This function
chooses a locally-meaningful number for the function, and records it
locally.  No attempt is made to ensure consistency across processors.}

\function {void CmiNumberHandler(int n, CmiHandler h)}
\index{CmiNumberHandler}
\desc{Forces the system to associate the specified handler number {\em n}
with the specified handler function {\em h}.  If the function number
{\em n} was previously mapped to some other function, that old mapping
is forgotten.  The mapping that this function creates is local to the
current processor.  CmiNumberHandler can be useful in combination with
CmiRegisterGlobalHandler.  It can also be used to implement
user-defined numbering schemes: such schemes should keep in mind that
the size of the table that holds the mapping is proportional to the
largest handler number --- do not use big numbers!}

Note: of the three registration methods, the CmiRegisterHandler method
is by far the simplest, and is strongly encouraged.  The others are
primarily to ease the porting of systems that already use similar
registration techniques.  One may use all three registration methods
in a program.  The system guarantees that no numbering conflicts will
occur as a result of this combination.

\function {\#define CmiMsgHeaderSizeBytes}
\index{CmiMsgHeaderSizeBytes}
\desc{Messages are continguous sequences of bytes.  The first few
bytes bytes of the message is the {\em CMI header}.  The size of the
header is defined by the preprocessor constant CmiMsgHeaderSizeBytes,
which is found in in {\tt converse.h}.  When the user allocates a message,
this number of bytes must be set aside at the front of the message for
the {\em CMI header.}}

\function {void CmiSetHandler(int *MessageBuffer, int HandlerId)}
\index{CmiSetHandler}
\desc{This macro sets the handler number of a message to \param{HandlerId}.}
 
\function {int CmiGetHandler(int *MessageBuffer)}
\index{CmiGetHandler}
\desc{This call returns the handler of a message in the form of a handler number.}
 
\function {CmiHandler CmiGetHandlerFunction(int *MessageBuffer)}
\index{CmiGetHandlerFunction}
\desc{This call returns the handler of a message in the form of a function pointer.}

\section{Point-To-Point Communication}

\function{void CmiSyncSend(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiSyncSend}
\desc{Sends \param{msg} of size \param{size} bytes to processor
\param{destPE}. Message buffer for \param{msg} could be reused after
the call returns.
The first CmiMsgHeaderSizeBytes bytes of \param{msg} must be set aside
for use by the system.  (This applies to all the calls below that send
or broadcast a message.)}

\function{void CmiSyncSendAndFree(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiSyncSendAndFree}
\desc{Sends \param{msg} of size \param{size} bytes to processor
\param{destPE} and frees the message buffer for \param{msg}.}

\function{CmiCommHandle CmiAsyncSend(unsigned int destPE, unsigned int size, void *msg)}
\index{CmiAsyncSend}
\desc{Initiates an asynchronous send of \param{msg} of length
\param{size} bytes to processor \param{destPE} and returns a
communication handle which could be used to enquire the status of this
communication. Message buffer for \param{mesg} should not be reused or freed
until communication is complete.}

\function{int CmiAsyncMsgSent(CmiCommHandle handle)}
\index{CmiAsyncMsgSent}
\desc{Returns the status of asynchronous send specified by
communication handle \param{handle}.}

\function{void CmiReleaseCommHandle(CmiCommHandle handle)}
\index{CmiReleaseCommHandle}
\desc{Releases the communication handle \param{handle} and
associated resources. It does not free the message buffer.
\param{handle} could be reused by CMI for another communication after
this call succeeds.}

\function{CmiCommHandle CmiAsyncVectorSend(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Initiates an asynchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
This function returns a communication handle which could be used to enquire
about the status of communication using \param{CmiAsyncMsgSent()}.
Individual pieces of data as well as the arrays \param{sizes} and
\param{msgComps} should not be overwritten or freed before the
communication is complete.}

\function{void CmiSyncVectorSend(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Synchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
\param{sizes}, \param{msgComps} and the message components specified in
\param{msgComps} could be reused after the function call returns.
}

\function{void CmiSyncVectorSendAndFree(int destPE, int len, int sizes[], char *msgComps[])}
\desc{Synchronous send of data to processor
\param{destPE}.  The data consists of \param{len} pieces residing in
different areas of memory, which are logically concatenated.  The
\param{msgComps} array contains pointers to the pieces; the size of
\param{msgComps[i]} is taken from \param{sizes[i]}. 
The message components specified in \param{msgComps} are freed by this function
therefore, they should be dynamically allocated using \param{CmiAlloc()}.
However, the \param{sizes} and \param{msgComps} array themselves are not
freed. 
}

\function{void CmiGrabBuffer(void **pbuf)}
\index{CmiGrabBuffer}
\desc{Transfers the ownership of the buffer pointed to by
\param{*pbuf} to the calling procedure. On machines where 
\param{*pbuf} points to a
system buffer which cannot be allocated to the user, 
CMI copies the buffer contents to newly allocated user
space and updates \param{*pbuf} to point to the new buffer.
In either case, the user should eventually free the buffer by calling
\param{CmiFree}.}

\function{int CmiDeliverMsgs(int MaxMsgs)}
\index{CmiDeliverMsgs}
\desc{Retrieves messages from the network message queue and invokes 
corresponding handler functions for arrived messages. This function 
returns after either the network message queue becomes empty or after
\param{MaxMsgs} messages have been retrieved and their handlers called. 
It returns the difference between total messages delivered and \param{MaxMsgs}.
The handler is given a pointer to the message as  its parameter.
Normally, the delivered message is owned by CMI,  and so the handler
should not free it, or store it for later use.  
If the handler wishes to  use the message later (for example, by
enqueueing the message with the scheduler), it must call
\param{CmiGrabBuffer()} to
acquire the  ownership of the message buffer.}

\function{void CmiDeliverSpecificMsg(int HandlerId)}
\index{CmiDeliverSpecificMsg}
\desc{Retrieves messages from the network queue and delivers the first message
with its handler field equal to \param{HandlerId}. This functions queues
the remaining messages retrieved from the network. It returns after the 
invoked handler function returns.}

\internal{
\section{Global Pointer}

\function{int CmiGptrCreate(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{This function creates a global pointer by initializing contents of
\param{*gptr} to point to memory on the local processor pointed to by
\param{lptr} of \param{size} bytes. \param{*gptr} could then be sent to other 
processors, and could be used by \param{CmiGet()} and \param{CmiPut()}
to read and write this memory by remote processors. This functions returns
a positive integer on success.}

\function{void *CmiGptrDref(GlobalPtr *gptr)}
\desc{This function returns the address of local memory associated
with global pointer \param{gptr}.}

\function{int CmiSyncGet(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Copies \param{size} bytes from 
memory pointed to by global pointer \param{gptr}
to local memory pointed to by \param{lptr}. 
This is a synchronous operation and the calling processor blocks until
the data is transferred to local memory. This function returns
a positive integer on success.}

\function{CommHandle CmiGet(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Initiates copying of \param{size} bytes from 
memory pointed to by global pointer \param{gptr}
to local memory pointed to by \param{lptr}. 
This function returns a  communication handle which could be used
to  enquire about the status of this operation.}

\function{CommHandle CmiPut(GlobalPtr *gptr, void *lptr, unsigned int size)}
\desc{Initiates copying of \param{size} bytes from a processor's local
memory pointed to by \param{lptr} to the memory pointed to by global
pointer \param{gptr}.  This function returns a  communication handle
which could be used to  enquire about the status of this operation.}
}

\section{Broadcast}

\function{void CmiSyncBroadcast(unsigned int size, void *msg)}
\index{CmiSyncBroadcast}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
excluding the processor on which the caller resides. }

\function{void CmiSyncBroadcastAndFree(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAndFree}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
excluding the processor on which the caller resides. Frees the message buffer
for \param{msg} when the broadcast completes. Therefore \param{msg} must
point to a dynamically allocated buffer.}

\function{void CmiSyncBroadcastAll(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAll}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
including the processor on which the caller resides. This function
does not free the message buffer for \param{msg}.}

\function{void CmiSyncBroadcastAllAndFree(unsigned int size, void *msg)}
\index{CmiSyncBroadcastAllAndFree}
\desc{Sends \param{msg} of length \param{size} bytes to all processors
including the processor on which the caller resides. This function
frees the message buffer for \param{msg} before returning, so
\param{msg} must point to a dynamically allocated buffer.}

\function{CmiCommHandle CmiAsyncBroadcast(unsigned int size, void *msg)}
\index{CmiAsyncBroadcast}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors excluding the processor on
which the caller resides. It returns a communication handle which
could be used to check the status of this send using
\param{CmiAsyncMsgSent()}. \param{msg} should not be overwritten or
freed before the communication is complete.}

\function{CmiCommHandle CmiAsyncBroadcastAll(unsigned int size, void *msg)}
\index{CmiAsyncBroadcastAll}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors including the processor on
which the caller resides. It returns a communication handle which
could be used to check the status of this send using
\param{CmiAsyncMsgSent()}. \param{msg} should not be overwritten or
freed before the communication is complete.}

\section{Timer}

\function{double CmiTimer(void)}
\index{CmiTimer}
\desc{Returns current value of the timer in seconds. This is
typically the time spent since the \param{ConverseInit()} call.
The precision of this timer is the best available on the particular machine,
and usually has at least microsecond accuracy.}

\section{Processor Ids}

\function{int CmiNumPe(void)}
\index{CmiNumPe}
\desc{Returns total number of processors in the machine on which the 
parallel program is being run.}

\function{int CmiMyPe(void)}
\index{CmiMyPe}
\desc{Returns the logical processor identifier of processor on which the 
caller resides. A processor Id is between \param{0} and \param{CmiNumPe()-1}.}

Also see the calls in Section~\ref{utility}.  % put a ref here..??

\section{Memory Management}

\function{void *CmiAlloc(int size)}
\index{CmiAlloc}
\desc{Allocates memory of size \param{size} in heap and returns pointer to 
the usable space. All the converse entities (e.g. messages) should be 
allocated with \param{CmiAlloc} and not with standard C library 
functions such as \param{malloc} because converse uses \param{CmiFree} to free 
these entities internally. \note{Currently this function is a simple wrapper
around \param{malloc}. However, in future, sophisticated memory allocation
strategies will be incorporated into converse.}}

\function{int CmiSize(void *ptr)}
\index{CmiSize}
\desc{This function returns the allocated size of memory pointed to by 
\param{ptr}. \param{ptr} should be returned by an earlier call to 
\param{CmiAlloc}.}

\function{void CmiFree(void *ptr)}
\index{CmiFree}
\desc{This function frees the memory pointed to by \param{ptr}. \param{ptr}
should be returned by an earlier call to \param{CmiAlloc}.}


\section{Input/Output}

\function{void CmiPrintf(char *format, arg1, arg2, ...)}
\index{CmiPrintf}
\desc{This function does an atomic \param{printf()} on \param{stdout}. 
On machine with host, this is implemented on top of the messaging 
layer using asynchronous sends.}

\function{int CmiScanf(char *format, void *arg1, void *arg2, ...)}
\index{CmiScanf}
\desc{This function performs an atomic \param{scanf} from \param{stdin}.
The processor, on which the caller resides, blocks for input. On machines with
host, this is implemented on top of the messaging layer using asynchronous
send and blocking receive.}

\function{void CmiError(char *format, arg1, arg2, ...)}
\index{CmiError}
\desc{This function does an atomic \param{printf()} on \param{stderr}. 
On machines with host, this is implemented on top of the messaging 
layer using asynchronous sends.}

\internal{
\section{Processor Groups}

\function{void CmiPgrpCreate(Pgrp *group)}
\desc{Creates a processor-group with calling processsor as the root processor.}

\function{void CmiPgrpDestroy(Pgrp *group)}
\desc{Frees resources associated with a processor group \param{group}.}

\function{void CmiAddChildren(Pgrp *group, int penum, int size, int procs[])}
\desc{Adds \param{size} processors from array \param{procs[]} to the
processor-group \param{group} as children of processor penum. This function
could be called only by the root processor of processor-group \param{group}.}

\function{CommHandle CmiAsyncMulticast(Pgrp *group, unsigned int size, void *msg)}
\desc{Initiates asynchronous broadcast of message \param{msg} of
length \param{size} bytes to all processors belonging to \param{group}
excluding the processor on which the caller resides. It returns a
communication handle which could be used to check the status of this
send using \param{CmiAsyncMsgSent()}. \param{msg} should not be
overwritten or freed before the communication is complete. \note{Caller
need not belong to \param{group}.}} 

\function{int CmiPgrpRoot(Pgrp *group)}
\desc{Returns the processor id of root of processor-group \param{group}. }

\function{int CmiNumChildren(Pgrp *group, int penum)}
\desc{Returns  number of children of processor \param{penum} 
in the processor-group \param{group}.}

\function{int CmiParent(Pgrp *group, int penum)}
\desc{Returns  processor id of parent of processor \param{penum} 
in the processor-group \param{group}.}

\function{void CmiChildren(Pgrp *group, int node, int *children)}
\desc{Fills in array \param{children} with processor ids of all the
children processor \param{node} in processor-group \param{group}. This
array should at least be of size \param{CmiNumChildren()}.}
}

\section{Spanning Tree Calls}

Converse defines a spanning tree organization of the processor procNums along
with routines for accessing elements of that tree.  The spanning tree
routines come in handy when writing programs with collective communication
because message communication patterns can be made to proceed along the
spanning tree arcs to avoid bottlenecks at a single procNum.

\function{int CmiSpanTreeRoot()}
\index{CmiSpanTreeRoot}
\desc{Returns the processor number of the root of the spanning tree.}

\function{int CmiSpanTreeParent(int procNum)}
\index{CmiSpanTreeParent}
\desc{This function returns the processor number of the parent of
\param{procNum} in the spanning tree.}

\function{int CmiNumSpanTreeChildren(int procNum)}
\index{CmiNumSpanTreeChildren}
\desc{Returns the number of children of \param{procNum} in the spanning tree.}

\function{void CmiSpanTreeChildren(int procNum, int *children)}
\index{CmiSpanTreeChildren}
\desc{This function fills the array \param{children} with processor
numbers of children of \param{procNum} in the spanning tree.}

